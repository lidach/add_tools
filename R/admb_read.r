#' @title admb_read
#'
#' @description read tpl into ADMB
#'
#' @param fn ADMB model name
#'
#' @return ADMB files
#'
#' @export
#'

admb_read <- function(fn, verbose = FALSE,
                      profile = FALSE,
                      mcmc = FALSE,
                      mcmc.opts = NULL,
                      admbOut = NULL,
                      checkterm = TRUE) {
  tpldat <- read_tpl(fn) ## extract info from TPL file
  if (verbose) cat("reading output ...\n")
  parfn <- paste(fn, "par", sep = ".")
  if (!file.exists(parfn)) stop("couldn't find parameter file ", parfn)
  L <- c(list(fn = fn, txt = admbOut), read_pars(fn))
  if (mcmc) {
    ## if (checkparam!="write") {
    ## warning("MCMC naming is probably wrong")
    ## }
    ## FIXME: get MCMC names -- how?
    if (file.exists(paste(fn, "hst", sep = "."))) {
      L <- c(L, list(hist = read_hst(fn)))
    }
    if (is.null(mcmc.opts)) {
      ## try to retrieve mc info from file
      mcinfofile <- paste(fn, "mcinfo", sep = ".")
      if (file.exists(mcinfofile)) {
        w <- readLines(mcinfofile)
        wnames <- gsub("^# +", "", w[seq(1, length(w), by = 2)])
        wvals <- as.list(w[seq(2, length(w), by = 2)])
        wvals[c(1, 2, 5)] <- as.numeric(wvals[c(1, 2, 5)])
        wvals[3:4] <- as.logical(wvals[3:4])
        wvals[[6]] <- strsplit(wvals[[6]], " ")[[1]]
        names(wvals) <- wnames
        mcmc.opts <- wvals
      } else {
        warning("having difficulty retrieving MCMC info, will try to continue anyway")
      }
    }
    ## if (is.null(mcmc.opts) || is.null(mcmc.opts$mcmcpars) || nchar(mcmc.opts$mcmcpars)==0) {
    ## pnames <- gsub("r_","",tpldat$info$sdnums$vname)
    ## } else pnames <- mcmc.opts$mcmcpars
    sdinfo <- read.table(paste(fn, "std", sep = "."), skip = 1)
    pnames <- rep_pars(sdinfo[, 2])
    ## pnames <- grep("^r_.*",pnames,value=TRUE,invert=TRUE)
    sdreportvars <- as.character(tpldat$info$sdnums$vname)
    pnames <- setdiff(pnames, sdreportvars)
    if (is.null(mcmc.opts) || mcmc.opts[["mcsave"]] > 0) {
      ## exclude autogenerated sdreport variables
      mcpnames <- pnames[!grepl("^r_", pnames)]
      L$mcmc <- read_psv(fn, names = mcpnames)
      ## FIXME: account for mcmc2 if appropriate
      attr(L$mcmc, "mcpar") <- c(1, mcmc.opts[["mcmc"]], mcmc.opts[["mcsave"]])
    }
  }
  if (profile) {
    if (!is.null(tpldat$info$raneff)) {
      stop("something's wrong -- profiling is not implemented for random effects models")
    }
    profpars <- tpldat$info$profparms$vname
    L$prof <- lapply(profpars, read_plt)
    names(L$prof) <- gsub("p_", "", profpars) ## FIXME: maybe dangerous?
  }
  ## compute termination criteria
  ##  can we retrieve hessian directly???
  if (checkterm) {
    v <- with(L, vcov[seq(npar), seq(npar)])
    ev <- try(eigen(solve(v))$value, silent = TRUE)
    L$eratio <- if (inherits(ev, "try-error")) NA else min(ev) / max(ev)
  }
  class(L) <- "admb"
  L
}
